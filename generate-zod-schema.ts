// deno run --allow-net --allow-env supabase/generate-zod-schema.ts
import 'https://deno.land/std@0.224.0/dotenv/load.ts';

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.7';

// ENV
const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!;
const SUPABASE_KEY = Deno.env.get('SUPABASE_KEY')!;
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

// Fetch all enums and their values
async function getEnumTypes() {
  const { data, error } = await supabase.rpc('enum_types');
  if (error) {
    console.error('ERROR: Failed to fetch enum_types RPC');
    throw error;
  }
  const enums: Record<string, string[]> = {};
  for (const row of data) {
    const key = row.enum_name.toLowerCase();
    if (!enums[key]) {
      enums[key] = [];
    }
    enums[key].push(row.enum_value);
  }
  return enums;
}

// Get all table names
async function getTableNames() {
  const { data, error } = await supabase.rpc('list_public_tables');
  if (error) {
    throw error;
  }
  return data.map((row: any) => row.table_name);
}

// Get columns for a table
async function getTableColumns(table: string) {
  const { data, error } = await supabase
    .rpc('get_table_details', { target_table: table });
  if (error) {
    console.error('ERROR: Failed to fetch get_table_details RPC for', table);
    throw error;
  }
  return data;
}

// Zod type mapping
function pgTypeToZod(type: string, udtName?: string) {
  const normalizedUdt = (udtName || '').toLowerCase();
  if (enumTypes[normalizedUdt]) {
    const schemaName = `${toCamelCase(normalizedUdt)}Schema`;
    if (!enumSchemas.find(e => e.name === schemaName)) {
      enumSchemas.push({
        name: schemaName,
        code: `export const ${schemaName} = z.union([${enumTypes[normalizedUdt].map((v: string) => `z.literal('${v}')`).join(', ')}]);`,
      });
    }
    return schemaName;
  }
  switch (type) {
    case 'integer':
    case 'bigint':
    case 'smallint':
    case 'numeric':
    case 'real':
    case 'double precision':
      return 'z.number()';
    case 'boolean':
      return 'z.boolean()';
    case 'json':
    case 'jsonb':
      return 'jsonSchema';
    case 'timestamp with time zone':
    case 'timestamp without time zone':
    case 'date':
    case 'time without time zone':
    case 'text':
    case 'uuid':
    case 'character varying':
    case 'character':
      return 'z.string()';
    default:
      return 'z.any()';
  }
}

function toCamelCase(str: string) {
  return str.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
}
function upperFirst(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function getExportName(table: string, mode: 'row' | 'insert' | 'update') {
  let base = toCamelCase(table);
  base = base.replace(/^[a-z]/, c => c.toLowerCase());
  let suffix = '';
  if (mode === 'row') {
    suffix = 'RowSchema';
  }
  if (mode === 'insert') {
    suffix = 'InsertSchema';
  }
  if (mode === 'update') {
    suffix = 'UpdateSchema';
  }
  return `${base}${upperFirst(suffix)}`;
}
function genZodObject(cols: any[], mode: 'row' | 'insert' | 'update') {
  const sortedCols = [...cols].sort((a, b) =>
    a.column_name.localeCompare(b.column_name),
  );
  return (
    `z.object({\n${
      sortedCols
        .map((col) => {
          const zodType = pgTypeToZod(col.data_type, col.udt_name);
          let modifiers = '';

          if (mode === 'update') {
          // All fields optional in update
            modifiers += '.optional()';
          } else if (mode === 'insert') {
            if (
              col.is_nullable === 'YES'
              || col.is_identity === 'YES'
              || col.column_default !== null
            ) {
              modifiers += '.optional()';
            }
          }
          if (col.is_nullable === 'YES') {
            modifiers += '.nullable()';
          }
          return `  ${col.column_name}: ${zodType}${modifiers},`;
        })
        .join('\n')
    }\n})`
  );
}

// Main
console.log('// This file is auto-generated by supabase/generate-zod-schema.ts. Do not edit manually.\n');
console.log('import { z } from "zod";');
console.log('export const jsonSchema = z.any();\n');

const enumTypes = await getEnumTypes();
const enumSchemas: { name: string; code: string }[] = [];
const tableNames = await getTableNames();
tableNames.sort();
const allExports: { name: string; code: string }[] = [];

for (const table of tableNames) {
  for (const mode of ['row', 'insert', 'update'] as const) {
    const exportName = getExportName(table, mode);
    allExports.push({
      name: exportName,
      code: `export const ${exportName} = ${genZodObject(await getTableColumns(table), mode)};\n`,
    });
  }
}

// Print enums first, sorted
enumSchemas.sort((a, b) => a.name.localeCompare(b.name));
for (const e of enumSchemas) {
  console.log(e.code);
}

for (const exp of allExports) {
  console.log(exp.code);
}
